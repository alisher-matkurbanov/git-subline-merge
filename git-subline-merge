#!/usr/bin/env python

#
#  git-subline-merge
#
#  Created by Paul Altin on 02.03.18.
#

#
# An interactive git merge driver which can resolve non-overlapping conflicts on individual or adjacent lines.
#
# To install, add these lines to your ~/.gitconfig:
#
#     [merge "git-subline-merge"]
#         name = An interactive merge driver for resolving sub-line conflicts
#         driver = git-subline-merge %O %A %B %L %P
#         recursive = binary
#
# and this to your git attributes file (e.g. ~/.config/git/attributes):
#
#     * merge=git-subline-merge
#


import os, sys, re, tempfile
from subprocess import call
from shutil import copyfile

if os.name == 'nt':
    from colorama import init

# Python 2 compatibility
from builtins import input

# syntax highlighting
from pygments import highlight
from pygments.styles import get_style_by_name
from pygments.lexers import get_lexer_for_filename
from pygments.formatters import Terminal256Formatter


###############
### HELPERS ###
###############

# for colored output in terminal
class color:

    bold = '\033[1m'
    red = '\033[91m'
    green = '\033[92m'
    yellow = '\033[93m'
    blue = '\033[94m'
    purple = '\033[95m'
    cyan = '\033[96m'
    black = '\033[30m'
    bg_red = '\033[41m'
    bg_yellow = '\033[103m'
    bg_green = '\033[42m'
    end = '\033[0m'

    info = cyan
    highlight = bg_yellow + black
    added = bg_green
    deleted = bg_red
    success = green
    warning = yellow
    error = red


# get number of lines in a file, either from a name or a file handle
# if given a handle, ensure position is reset to its original value
def file_len(f):
    i = 0
    # file
    try:
        with open(f, 'r') as fh:
            for i,l in enumerate(fh):
                pass
    # file handle
    except TypeError:
        pos = f.tell()
        f.seek(0)
        for i,l in enumerate(f):
            pass
        f.seek(pos)

    return i + 1


# get the line numbers of the beginning and end of a conflicted hunk
def find_nth_conflicted_hunk(file, n):
    start = stop = -1
    with open(file, 'r') as f:
        m = 0
        for i,l in enumerate(f):
            if l.startswith(marker_start):
                m += 1
                if (m == n and start == -1):
                    start = i
            elif start >= 0 and l.startswith(marker_end):
                stop = i + 1
                break
    if start == -1 or stop == -1:
        raise IndexError('Hunk %d hunk not found!' % n)
    return (start, stop)


# find nth conflict in file and replace it with given lines
def replace_nth_conflicted_hunk_with_lines(file, n, lines):
    contents = None
    with open(file, 'r') as f:
        contents = f.readlines()
    start, stop = find_nth_conflicted_hunk(file, n)
    contents[start:stop] = lines
    with open(file, 'w') as f:
        f.write(''.join(contents))


# prompt user for input, repeating until one of the allowed responses is given
def ask_for_input(msg, allowed=None):

    # when run from git on *nix, stdin isn't connected to the terminal
    # reconfigure stdin to prompt, then return it to its previous state
    if os.name != 'nt':
        sys.stdin = open('/dev/tty')

    if allowed is not None:
        msg = color.bold + color.info + msg + ' (' + '/'.join(allowed) + ')? ' + color.end
        while True:
            r = input(msg).strip().lower()
            if r in [s.strip().lower() for s in allowed]:
                break
    else:
        msg = color.bold + color.info + msg + color.end
        r = input(msg)

    sys.stdin = sys.__stdin__
    return r

# get exit status from a call to os.system
# on Windows, os.WEXITSTATUS() doesn't work and os.system() returns the status directly
def get_exit_status(exit_code):
    return exit_code if (os.name == 'nt') else os.WEXITSTATUS(exit_code)



#############
### DIFFS ###
#############

# find line numbers of added, deleted and changed lines
def classify_diff_lines(file1, file2):

    # for added and deleted groups, get the (zero-indexed) number of the first line and the length of the group
    # for changed groups, get the (zero-indexed) numbers of the first and one past the last line
    # ideally we'd use \n as the delimiter, but these break the shell on Windows
    delimiter = marker_start + "GIT_SUBLINE_MERGE_DELIMITER" + marker_end
    oldformat = ' --old-group-format="D%de+%dn,%dE+%dN' + delimiter + '" '
    newformat = ' --new-group-format="A%de+%dn,%dE+%dN' + delimiter + '" '
    changedformat = ' --changed-group-format="C%de+%dl,%dE+%dL' + delimiter + '" '
    unchangedformat = ' --unchanged-group-format="" '
    cmd = 'diff' + oldformat + newformat + changedformat + unchangedformat + file1 + ' ' + file2
    hunks = [h for h in os.popen(cmd).read().split(delimiter) if len(h)]

    # extract indices from diff output
    # added and deleted are a list of line numbers
    # changed are lists of (start, stop) pairs
    added, deleted, oldchange, newchange = [], [], [], []

    for h in hunks:
        if h[0] == 'A':
            a = h[1:].split(',')[1]
            start,length = [int(x) for x in a.split('+')]
            added += list(range(start, start+length))
        elif h[0] == 'D':
            d = h[1:].split(',')[0]
            start,length = [int(x) for x in d.split('+')]
            deleted += list(range(start, start+length))
        elif h[0] == 'C':
            c = h[1:].split(',')
            start,stop = [int(x) for x in c[0].split('+')]
            oldchange += [[start, stop]]
            start,stop = [int(x) for x in c[1].split('+')]
            newchange += [[start, stop]]

    return added, deleted, oldchange, newchange


# print diff lines with coloring
def print_added_line(ln):
    print('+ ' + color.added + ln + color.end)

def print_deleted_line(ln):
    print('- ' + color.deleted + ln + color.end)

def print_unchanged_line(ln):
    print('  ' + ln)

def print_changed_hunk(h1, h2, which):

    # split lines at non-word characters
    # keep track of where the linebreaks are in terms of segment index
    splA, splB, lcA, lcB = [], [], [0], [0]
    for ln in h1:
        segments = re.split('(\W)', ln)
        splA += segments
        lcA.append(lcA[-1] + len(segments))
    for ln in h2:
        segments = re.split('(\W)', ln)
        splB += segments
        lcB.append(lcB[-1] + len(segments))
    lcA.pop(0)
    lcB.pop(0)

    # write split lines to temp files
    tmpA = tempfile.NamedTemporaryFile(mode='w+')
    tmpA.write('\n'.join(splA))
    tmpA.flush()
    tmpB = tempfile.NamedTemporaryFile(mode='w+')
    tmpB.write('\n'.join(splB))
    tmpB.flush()

    # use diff to find added and removed section indices
    old = os.popen('diff --unchanged-line-format="." --old-line-format="-" --new-line-format="" ' + tmpA.name + ' ' + tmpB.name).read()
    new = os.popen('diff --unchanged-line-format="." --old-line-format="" --new-line-format="+" ' + tmpA.name + ' ' + tmpB.name).read()

    removed = []
    for i,c in enumerate(old):
        if c == '-':
            removed.append(i)
    added = []
    for i,c in enumerate(new):
        if c == '+':
            added.append(i)

    if which == 'old':
        sys.stdout.write('* ')
        for i,w in enumerate(splA):
            if i in lcA:
                sys.stdout.write('\n* ')
            if i in removed:
                sys.stdout.write(color.deleted)
            sys.stdout.write(highlight(w, lexer, formatter).rstrip('\n'))
            sys.stdout.write(color.end)
        print('')

    elif which == 'new':
        sys.stdout.write('* ')
        for i,w in enumerate(splB):
            if i in lcB:
                sys.stdout.write('\n* ')
            if i in added:
                sys.stdout.write(color.added)
            sys.stdout.write(highlight(w, lexer, formatter).rstrip('\n'))
            sys.stdout.write(color.end)
        print('')

    tmpA.close()
    tmpB.close()


# print colorized diffs
def show_diff(fh1, fh2, which):

    a,d,o,n = classify_diff_lines(fh1.name, fh2.name)

    fh1.seek(0)
    f1 = fh1.read().splitlines()
    fh2.seek(0)
    f2 = fh2.read().splitlines()
    i, ch = 0, 0

    if which == 'old':
        while i < len(f1):
            if i in d:
                print_deleted_line(f1[i])
            elif ch < len(o) and i == o[ch][0]:
                old = f1[o[ch][0]:o[ch][1]]
                new = f2[n[ch][0]:n[ch][1]]
                print_changed_hunk(old, new, 'old')
                i += o[ch][1] - o[ch][0] - 1
                ch += 1
            else:
                print_unchanged_line(f1[i])
            i += 1


    elif which == 'new':
        while i < len(f2):
            if i in a:
                print_added_line(f2[i])
            elif ch < len(n) and i == n[ch][0]:
                old = f1[o[ch][0]:o[ch][1]]
                new = f2[n[ch][0]:n[ch][1]]
                print_changed_hunk(old, new, 'new')
                i += n[ch][1] - n[ch][0] - 1
                ch += 1
            else:
                print_unchanged_line(f2[i])
            i += 1



###############
### MERGING ###
###############

def process_hunk(hunk, index, resolved, num_conflicts):

    first_run = True
    fixed = abort = False

    # get number of lines in current, base and other hunks
    sizes = [file_len(f) for f in hunk]

    # only process small hunks
    if all([s <= 32 for s in sizes]):

        print(color.bold + color.highlight + '\nConflicted hunk %d of %d (spans %d/%d/%d lines) in %s...' % (index, num_conflicts, sizes[0], sizes[1], sizes[2], filename) + color.end)

        # ask user for action to take
        while True:

            if first_run:
                print('')
                action = 'v'
                first_run = False
            else:
                print('')
                print(color.bold + '   v - view entire hunk' + color.end)
                print(color.bold + '   c - view hunk in context' + color.end)
                print(color.bold + '   s - attempt sub-line merge' + color.end)
                print(color.bold + '   m - resolve manually' + color.end)
                print(color.bold + '   k - skip this hunk' + color.end)
                print(color.bold + '   q - skip all hunks in this file' + color.end)
                action = ask_for_input('Resolve this hunk', ['v','c','s','m','k','q'])
                print('')

            # actions
            for f in hunk: f.seek(0)
            if action == 'c':
                start, stop = find_nth_conflicted_hunk(current, index-resolved)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(max(0, start-10), start):
                            print(highlight(l, lexer, formatter).rstrip('\n'))
                        elif i >= start:
                            break
            if action in ['v','c']:
                print(color.info + marker_start + ' Current version' + color.end)
                show_diff(hunk[1], hunk[0], 'new')
                print(color.info + marker_base + ' Base version' + color.end)
                show_diff(hunk[1], hunk[0], 'old')
                print(color.info + marker_other + color.end)
                show_diff(hunk[1], hunk[2], 'old')
                print(color.info + marker_base + ' Base version' + color.end)
                show_diff(hunk[1], hunk[2], 'new')
                print(color.info + marker_end + ' Other version' + color.end)
            if action == 'c':
                length = file_len(current)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(stop, min(stop+10, length)):
                            print(highlight(l, lexer, formatter).rstrip('\n'))
                        elif i >= stop:
                            break
            elif action == 's':
                result = subline_merge_hunk(hunk)
                if result is not None:
                    print(color.info + marker_start + ' Sub-line merge yields:' + color.end)
                    if len(result): print(highlight('\n'.join([x.rstrip('\n') for x in result]), lexer, formatter).rstrip('\n'))
                    print(color.info + marker_end + color.end + '\n')
                    accept = ask_for_input('Accept sub-line merge', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        fixed = True
                        break
                else:
                    print(color.bold + color.error + 'Sub-line merge failed, hunk has overlapping changes' + color.end)
            elif action == 'm':
                result = manual_merge_hunk(hunk)
                if result is not None:
                    print(color.info + marker_start + ' Manual resolution is:' + color.end)
                    if len(result): print(highlight('\n'.join([x.rstrip('\n') for x in result]), lexer, formatter).rstrip('\n'))
                    print(color.info + marker_end + color.end + '\n')
                    accept = ask_for_input('Accept manual resolution', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        fixed = True
                        break
                else:
                    print(color.bold + color.warning + 'User cancelled manual resolve' + color.end)
            elif action == 'k':
                break
            elif action == 'q':
                abort = True
                break

    else:
        print(color.bold + color.info + '\nSkipping hunk %d of %d (spans %d/%d/%d lines) in %s, too large...' % (index, num_conflicts, sizes[0], sizes[1], sizes[2], filename) + color.end)

    return fixed, abort


# attempt to do sub-line merging of a conflicted hunk
def subline_merge_hunk(hunk):

    result = None
    fs = [None, None, None]

    # separate each character in a string by a newline character
    # on Windows the temp file can't be open twice, so we have to close it before calling
    #   git-merge-file and delete it manually later
    for i in range(3):
        h = hunk[i].read()
        fs[i] = tempfile.NamedTemporaryFile(mode='w+', delete=False)
        fs[i].write('\n'.join(h[i:i+1] for i in range(len(h))))
        fs[i].close()

    # attempt merge on separated text
    status = os.system('git merge-file %s %s %s' % (fs[0].name, fs[1].name, fs[2].name))
    num_conflicts = get_exit_status(status)

    # if successful, take merge result after removing newlines
    # split into a list of lines
    if (num_conflicts == 0):
        with open(fs[0].name, 'r+') as f0:
            h = f0.read()
        result = h[0::2].splitlines(True)

    for f in fs: os.unlink(f.name)

    return result


# open an editor for manual merging of a conflicted hunk
def manual_merge_hunk(hunk):

    # prepare temp file for editing
    f = tempfile.NamedTemporaryFile(mode='w+', delete=False)
    f.write(marker_start + ' Current version is:\n')
    f.write(hunk[0].read())
    f.write(marker_base + ' Base version is:\n')
    f.write(hunk[1].read())
    f.write(marker_other + ' Other version is:\n')
    f.write(hunk[2].read())
    f.write(marker_end + '\n')
    f.close()

    # use default editor (or vi if there isn't one)
    editor = os.getenv('GIT_EDITOR', 'vi')
    
    # when run from git on *nix, stdin isn't connected to the terminal
    # this causes some editors (e.g. vi) to behave strangely, so we set it explicitly
    windows = (os.name == 'nt')
    stdin_var = None if windows else open('/dev/tty')
    use_shell = False if windows else True

    # known issue with vi on Mac OS X: can give nonzero exit status even when quit cleanly due to
    # errors in .vimrc, so check its normal exit code first.
    success_code = 0
    if editor == 'vi':
        success_code = call(['vi -c "q" %s' % f.name], shell=use_shell, stdin=stdin_var)

    status = call(['%s %s' % (editor, f.name)], shell=use_shell, stdin=stdin_var)

    # if editor returned without an error, return the saved lines
    result = None
    if status <= success_code:
        with open(f.name, 'r') as f:
            result = f.readlines()
    os.unlink(f.name)

    return result



############
### MAIN ###
############

# arguments passed in by git:
# [1] name of temp file containing base version of file
# [2] name of temp file containing current version of file
# [3] name of temp file containing other version of file
# [4] length of conflict markers (default is 7 for <<<<<<<)
# [5] name of conflicted file
# the result should be left in the current version (argv[2])
base, current, other, marker_len, filename = sys.argv[1:]

# initialize colorama for colored terminal output on Windows
if os.name == 'nt':
    init()

# conflict markers can have custom lengths
marker_len = int(marker_len)
marker_start = '<' * marker_len
marker_base = '|' * marker_len
marker_other = '=' * marker_len
marker_end = '>' * marker_len

# run git merge on the files using diff3 (result is written to 'current')
# the number of conflicts is encoded in the exit status of the git-merge-file command
status = os.system('git merge-file --diff3 --marker-size=%d -L "Current version" -L "Base version" -L "Other version" %s %s %s' % (marker_len, current, base, other))
num_conflicts = get_exit_status(status)

# sometimes (e.g. during interactive rebase) this script is called even though
# there are no conflicts - in that case just exit successfully here
if num_conflicts == 0:
    sys.exit(0)

# pygments lexer and formatter for syntax coloring
lexer = get_lexer_for_filename(filename)
formatter = Terminal256Formatter(style=get_style_by_name('vim'))

# welcome message
print(color.bold + color.red + '\ngit-subline-merge v1.0\n' + color.end)

# make temporary files
# one is a copy of the conflicted 'current', to iterate with
# three are used to hold the different versions of each conflicted hunk
# open with 'a' so we can append without worrying about newline characters
tmp = tempfile.TemporaryFile(mode='w+')
with open(current, 'r') as c: tmp.write(c.read())
tmp.seek(0)
hunk = [ tempfile.NamedTemporaryFile(mode='a+'), tempfile.NamedTemporaryFile(mode='a+'), tempfile.NamedTemporaryFile(mode='a+') ]

# process file line by line
resolved = zone = index = 0

for line in tmp:

    # beginning of conflict zone
    if line.startswith(marker_start):
        zone = 1
        for f in hunk: f.truncate(0)

    # base version of conflict
    elif line.startswith(marker_base):
        zone = 2

    # other version of conflict
    elif line.startswith(marker_other):
        zone = 3

    # end of conflict zone
    elif line.startswith(marker_end):
        zone = 0
        index += 1
        fixed, abort = process_hunk(hunk, index, resolved, num_conflicts)
        if fixed: resolved += 1
        elif abort: break

    # append line to appropriate hunk zone
    elif zone:
        hunk[zone-1].write(line)


# close all temp files (will be automatically deleted)
tmp.close()
for h in hunk: h.close()

# print resolution
col = color.success if resolved == num_conflicts else color.warning if resolved > 0 else color.error
print(col + color.bold + '\nResolved %d of %d conflicts in %s\n' % (resolved, num_conflicts, filename) + color.end)

# de-initialize colorama
if os.name == 'nt':
    deinit()

# only exit with success if all conflicts were resolved
sys.exit(0 if resolved == num_conflicts else 1)

