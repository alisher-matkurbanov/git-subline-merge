#!/usr/bin/env python

#
#  git-subline-merge
#
#  Created by Paul Altin on 02.03.18.
#

#
# An interactive git merge driver which can resolve non-overlapping conflicts on individual or adjacent lines.
#
# To install, add these lines to your ~/.gitconfig:
#
#     [merge "git-subline-merge"]
#         name = An interactive merge driver for resolving sub-line conflicts
#         driver = git-subline-merge %O %A %B %L %P
#         recursive = binary
#
# and this to your git attributes file (e.g. ~/.config/git/attributes):
#
#     * merge=git-subline-merge
#


import os, sys, tempfile
from subprocess import call



###############
### HELPERS ###
###############

# for colored output in terminal
class color:
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    END = '\033[0m'


# get number of lines in a file, either from a name or a file handle
# if given a handle, ensure position is reset to its original value
def file_len(f):
    i = 0
    # file
    try:
        with open(f, 'r') as fh:
            for i,l in enumerate(fh):
                pass
    # file handle
    except TypeError:
        pos = f.tell()
        f.seek(0)
        for i,l in enumerate(f):
            pass
        f.seek(pos)

    return i + 1


# get the line numbers of the beginning and end of a conflicted hunk
def find_nth_conflicted_hunk(file, n):
    start = stop = -1
    with open(file, 'r') as f:
        m = 0
        for i,l in enumerate(f):
            if l.startswith(marker_start):
                m += 1
                if (m == n and start == -1):
                    start = i
            elif start >= 0 and l.startswith(marker_end):
                stop = i + 1
                break
    if start == -1 or stop == -1:
        raise IndexError('Hunk %d hunk not found!' % n)
    return (start, stop)


# find nth conflict in file and replace it with given lines
def replace_nth_conflicted_hunk_with_lines(file, n, lines):
    contents = None
    with open(file, 'r') as f:
        contents = f.readlines()
    start, stop = find_nth_conflicted_hunk(file, n)
    contents[start:stop] = lines
    with open(file, 'w') as f:
        f.write(''.join(contents))


# prompt user for input, repeating until one of the allowed responses is given
def ask_for_input(msg, allowed=None):

    # when run from git, stdin isn't connected to the terminal
    # reconfigure stdin to prompt, then return it to its previous state
    previous = sys.stdin
    sys.stdin = open('/dev/tty')

    if allowed is not None:
        msg = color.BOLD + color.BLUE + msg + ' (' + '/'.join(allowed) + ')? ' + color.END
        while True:
            r = raw_input(msg).strip().lower()
            if r in [s.strip().lower() for s in allowed]:
                break
    else:
        msg = color.BOLD + color.BLUE + msg + color.END
        r = raw_input(msg)

    sys.stdin = previous
    return r




###############
### MERGING ###
###############

def process_hunk(hunk, index, resolved, num_conflicts):

    first_run = True
    fixed = abort = False

    # get number of lines in current, base and other hunks
    sizes = [file_len(f) for f in hunk]

    # only process small hunks
    if all([s < 10 for s in sizes]):

        # ask user for action to take
        while True:

            if first_run:
                print ''
                action = 'v'
                first_run = False
            else:
                print color.BOLD + color.BLUE + '\nConflicted hunk %d of %d (spans %d/%d/%d lines) in %s...' % (index, num_conflicts, sizes[0], sizes[1], sizes[2], filename) + color.END
                print color.BOLD + '   v - view entire hunk' + color.END
                print color.BOLD + '   x - view hunk in context' + color.END
                print color.BOLD + '   c - view current version' + color.END
                print color.BOLD + '   b - view base version' + color.END
                print color.BOLD + '   o - view other version' + color.END
                print color.BOLD + '   s - attempt sub-line merge' + color.END
                print color.BOLD + '   m - resolve manually' + color.END
                print color.BOLD + '   k - skip this hunk' + color.END
                print color.BOLD + '   a - abort merge' + color.END
                action = ask_for_input('Resolve this hunk', ['v','x','c','b','o','s','m','k','a'])
                print ''

            # actions
            for f in hunk: f.seek(0)
            if action == 'x':
                start, stop = find_nth_conflicted_hunk(current, index-resolved)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(max(0, start-10), start):
                            print l.rstrip('\n')
                        elif i >= start:
                            break
            if action in ['v','x','c']:
                print color.RED + marker_start + ' Current version is:\n' + color.END + hunk[0].read().rstrip('\n')
            if action in ['v','x','b']:
                print color.RED + marker_base + ' Base version was:\n' + color.END + hunk[1].read().rstrip('\n')
            if action in ['v','x','o']:
                print color.RED + marker_other + ' Other version is:\n' + color.END + hunk[2].read().rstrip('\n')
            if action in ['v','x','c','b','o']:
                print color.RED + marker_end + color.END
            if action == 'x':
                length = file_len(current)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(stop, min(stop+10, length)):
                            print l.rstrip('\n')
                        elif i >= stop:
                            break
            elif action == 's':
                result = subline_merge_hunk(hunk)
                if result is not None:
                    print '\n' + color.RED + marker_start + ' Sub-line merge yields:' + color.END
                    if len(result): print '\n'.join([x.rstrip('\n') for x in result])
                    print color.RED + marker_end + color.END + '\n'
                    accept = ask_for_input('Accept sub-line merge', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        fixed = True
                        break
                else:
                    print color.BOLD + color.RED + 'Sub-line merge failed, hunk has overlapping changes' + color.END
            elif action == 'm':
                result = manual_merge_hunk(hunk)
                if result is not None:
                    print '\n' + color.RED + marker_start + ' Manual resolution is:' + color.END
                    if len(result): print '\n'.join([x.rstrip('\n') for x in result])
                    print color.RED + marker_end + color.END + '\n'
                    accept = ask_for_input('Accept manual resolution', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        fixed = True
                        break
                else:
                    print color.BOLD + color.YELLOW + 'User cancelled manual resolve' + color.END
            elif action == 'k':
                break
            elif action == 'a':
                abort = True
                break

    else:
        print color.BOLD + color.YELLOW + '\nSkipping hunk %d of %d (spans %d/%d/%d lines) in %s, too large...' % (index, num_conflicts, sizes[0], sizes[1], sizes[2], filename) + color.END

    return fixed, abort


# attempt to do sub-line merging of a conflicted hunk
def subline_merge_hunk(hunk):

    result = None
    fs = [None, None, None]

    # separate each character in a string by a newline character
    for i in range(3):
        h = hunk[i].read()
        fs[i] = tempfile.NamedTemporaryFile()
        fs[i].write('\n'.join(h[i:i+1] for i in range(len(h))))
        fs[i].flush()

    # attempt merge on separated text
    status = os.system('git merge-file %s %s %s' % (fs[0].name, fs[1].name, fs[2].name))
    num_conflicts = os.WEXITSTATUS(status)

    # if successful, take merge result after removing newlines
    # split into a list of lines
    if (num_conflicts == 0):
        fs[0].seek(0)
        h = fs[0].read()
        result = h[0::2].splitlines(True)

    for f in fs: f.close()

    return result


# open an editor for manual merging of a conflicted hunk
def manual_merge_hunk(hunk):

    # not necessary since we ask for confirmation afterwards anyway
    # # show instructions and wait for confirmation
    # print 'The conflicted hunk will now open in an editor for manual resolution.'
    # print 'Be sure to remove all conflict markers before saving. The file contents'
    # print '  will be inserted verbatim into the conflicted file.'
    # print 'To cancel manual resolve, force the editor to close with an error code.'
    # print '  (e.g. in vim, type :cq to cancel editing)'
    # ask_for_input('Press <Enter> to continue...')

    # prepare temp file for editing
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(marker_start + ' Current version is:\n')
    f.write(hunk[0].read())
    f.write(marker_base + ' Base version is:\n')
    f.write(hunk[1].read())
    f.write(marker_other + ' Other version is:\n')
    f.write(hunk[2].read())
    f.write(marker_end + '\n')
    f.close()

    # use default editor (or vi if there isn't one)
    editor = os.getenv('GIT_EDITOR', 'vi')

    # known issue with vi on Mac OS X: can give nonzero exit status even when quit cleanly due to
    # errors in .vimrc, so check its normal exit code first.
    success_code = 0
    if editor == 'vi':
        success_code = call(['vi -c "q" %s' % f.name], shell=True, stdin=open('/dev/tty'))

    # some editors (e.g. vi) behave strangely if stdin isn't the controlling terminal, so set it explicitly
    status = call(['%s %s' % (editor, f.name)], shell=True, stdin=open('/dev/tty'))

    # if editor returned without an error, return the saved lines
    result = None
    if status <= success_code:
        with open(f.name, 'r') as f:
            result = f.readlines()
    os.unlink(f.name)

    return result


############
### MAIN ###
############

# arguments passed in by git:
# [1] name of temp file containing base version of file
# [2] name of temp file containing current version of file
# [3] name of temp file containing other version of file
# [4] length of conflict markers (default is 7 for <<<<<<<)
# [5] name of conflicted file
base, current, other, marker_len, filename = sys.argv[1:]

# conflict markers can have custom lengths
marker_len = int(marker_len)
marker_start = '<' * marker_len
marker_base = '|' * marker_len
marker_other = '=' * marker_len
marker_end = '>' * marker_len

# run git merge on the files using diff3 (result is written to 'current')
# the number of conflicts is encoded in the exit status of the git-merge-file command
status = os.system('git merge-file --diff3 --marker-size=%d -L "Current version" -L "Base version" -L "Other version" %s %s %s' % (marker_len, current, base, other))
num_conflicts = os.WEXITSTATUS(status)

# sometimes (e.g. during interactive rebase) this script is called even though
# there are no conflicts - in that case just exit successfully here
if num_conflicts == 0:
    sys.exit(0)

# welcome message
print color.BOLD + color.RED + '\ngit-smart-merge v1.0\n' + color.END

# make temporary files
# one is a copy of the conflicted 'current', to iterate with
# three are used to hold the different versions of each conflicted hunk
# open with 'a' so we can append without worrying about newline characters
tmp = tempfile.TemporaryFile()
with open(current, 'r') as c: tmp.write(c.read())
tmp.seek(0)
hunk = [ tempfile.TemporaryFile(mode='a+'), tempfile.TemporaryFile(mode='a+'), tempfile.TemporaryFile(mode='a+') ]

# process file line by line
resolved = zone = index = 0

for line in tmp:

    # beginning of conflict zone
    if line.startswith(marker_start):
        zone = 1
        for f in hunk: f.truncate(0)

    # base version of conflict
    elif line.startswith(marker_base):
        zone = 2

    # other version of conflict
    elif line.startswith(marker_other):
        zone = 3

    # end of conflict zone
    elif line.startswith(marker_end):
        zone = 0
        index += 1
        fixed, abort = process_hunk(hunk, index, resolved, num_conflicts)
        if fixed: resolved += 1
        elif abort: break

    # append line to appropriate hunk zone
    elif zone:
        hunk[zone-1].write(line)


# close all temp files (will be automatically deleted)
tmp.close()
for h in hunk: h.close()

# print resolution
col = color.GREEN if resolved == num_conflicts else color.YELLOW if resolved > 0 else color.RED
print col + color.BOLD + '\nResolved %d of %d conflicts in %s\n' % (resolved, num_conflicts, filename) + color.END

# only exit with success if all conflicts were resolved
sys.exit(0 if resolved == num_conflicts else 1)

