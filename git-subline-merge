#!/usr/bin/env python

#
#  git-subline-merge
#
#  Created by Paul Altin on 02.03.18.
#

#
# An interactive git merge driver which can resolve non-overlapping conflicts on individual or adjacent lines.
#
# To install, add these lines to your ~/.gitconfig:
#
#     [merge "git-subline-merge"]
#         name = An interactive merge driver for resolving sub-line conflicts
#         driver = git-subline-merge %O %A %B %L %P
#         recursive = binary
#
# and this to your git attributes file (e.g. ~/.config/git/attributes):
#
#     * merge=git-subline-merge
#


import os, sys, tempfile
from subprocess import call


###############
### HELPERS ###
###############


# for colored output in terminal
class color:
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    END = '\033[0m'

# get number of lines in a file, either from a name or a file handle
# if given a handle, ensure position is reset to its original value
def file_len(f):
    i = 0
    if isinstance(f, file):
        pos = f.tell()
        f.seek(0)
        for i,l in enumerate(f):
            pass
        f.seek(pos)
    else:
        with open(f, 'r') as fh:
            for i,l in enumerate(fh):
                pass
    return i + 1


# separate each character in a string by a newline character
def add_newlines(string):
    newline = '\n'
    return newline.join(string)
def remove_newlines(string):
    newline = '\n'
    return ''.join(string.split(newline))


# get the line numbers of the beginning and end of a conflicted hunk
def find_nth_conflicted_hunk(file, n):
    start = stop = -1
    with open(file, 'r') as f:
        m = 0
        for i,l in enumerate(f):
            if l.startswith(marker_start):
                m += 1
                if (m == n and start == -1):
                    start = i
            elif start >= 0 and l.startswith(marker_end):
                stop = i + 1
                break
    if start == -1 or stop == -1:
        raise IndexError('%dth hunk not found!' % n)
    return (start, stop)


# find nth conflict in file and replace it with given lines
def replace_nth_conflicted_hunk_with_lines(file, n, lines):
    contents = None
    with open(file, 'r') as f:
        contents = f.readlines()
    start, stop = find_nth_conflicted_hunk(file, n)
    contents[start:stop] = lines
    with open(file, 'w') as f:
        f.write(''.join(contents))


# prompt user for input, repeating until one of the allowed responses is given
def ask_for_input(msg, allowed=None):

    # when run from git, stdin isn't connected to the terminal
    # reconfigure stdin to prompt, then return it to its previous state
    previous = sys.stdin
    sys.stdin = open('/dev/tty')

    if allowed is not None:
        msg = color.BOLD + color.BLUE + msg + ' (' + '/'.join(allowed) + ')? ' + color.END
        while True:
            r = raw_input(msg).strip().lower()
            if r in [s.strip().lower() for s in allowed]:
                break
    else:
        msg = color.BOLD + color.BLUE + msg + color.END
        r = raw_input(msg)

    sys.stdin = previous
    return r




###############
### MERGING ###
###############


# attempt to do sub-line merging of a conflicted hunk
def subline_merge_hunk(hunk):

    # get number of lines in current, base and other hunks
    sizes = [file_len(f) for f in hunk]

    result = None

    # only attempt sub-line merge if hunks are small and same size
    if (sizes[0] == sizes[1] == sizes[2] and sizes[0] < 10):

        lines = []
        success = True

        # process hunk line by line to avoid interline interaction
        # probably not necessary, since newline character would prevent unwanted side-effects
        for (i,c), b, o in zip(enumerate(hunk[0]), hunk[1], hunk[2]):
            fs = [None, None, None]
            for i,str in enumerate([c, b, o]):
                fs[i] = tempfile.NamedTemporaryFile()
                fs[i].write(add_newlines(str))
                fs[i].flush()
            status = os.system('git merge-file %s %s %s' % (fs[0].name, fs[1].name, fs[2].name))
            num_conflicts = os.WEXITSTATUS(status)
            if (num_conflicts > 0):
                success = False
                break;
            else:
                fs[0].seek(0)
                merged_line = remove_newlines(fs[0].read())
                lines.append(merged_line + '\n')
            for f in fs:
                f.close()

        if (success):
            result = lines

    return result


# open an editor for manual merging of a conflicted hunk
def manual_merge_hunk(hunk):

    # show instructions and wait for confirmation
    print 'The conflicted hunk will now open in an editor for manual resolution.'
    print 'Be sure to remove all conflict markers before saving. The file contents'
    print '  will be inserted verbatim into the conflicted file.'
    print 'To cancel manual resolve, force the editor to close with an error code.'
    print '  (e.g. in vim, type :cq to cancel editing)'
    ask_for_input('Press <Enter> to continue...')

    # prepare temp file for editing
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(marker_start + ' Current version is:\n')
    f.write(hunk[0].read())
    f.write(marker_base + ' Base version is:\n')
    f.write(hunk[1].read())
    f.write(marker_other + ' Other version is:\n')
    f.write(hunk[2].read())
    f.write(marker_end + '\n')
    f.close()

    # use default editor (or vi if there isn't one)
    editor = os.getenv('GIT_EDITOR', 'vi')

    # known issue with vi on Mac OS X: can give nonzero exit status even when quit cleanly due to
    # errors in .vimrc, so check its normal exit code first.
    success_code = 0
    if editor == 'vi':
        success_code = call(['vi -c "q" %s' % f.name], shell=True, stdin=open('/dev/tty'))

    # some editors (e.g. vi) behave strangely if stdin isn't the controlling terminal, so set it explicitly
    status = call(['%s %s' % (editor, f.name)], shell=True, stdin=open('/dev/tty'))

    # if editor returned without an error, return the saved lines
    result = None
    if status <= success_code:
        with open(f.name, 'r') as f:
            result = f.readlines()
    os.unlink(f.name)

    return result


############
### MAIN ###
############

# arguments passed in by git:
# [1] name of temp file containing base version of file
# [2] name of temp file containing current version of file
# [3] name of temp file containing other version of file
# [4] length of conflict markers (default is 7 for <<<<<<<)
# [5] name of conflicted file
base, current, other, marker_len, filename = sys.argv[1:]

# conflict markers can have custom lengths
marker_len = int(marker_len)
marker_start = '<' * marker_len
marker_base = '|' * marker_len
marker_other= '=' * marker_len
marker_end = '>' * marker_len

# run git merge on the files using diff3 (result is written to 'current')
# the number of conflicts is encoded in the exit status of the git-merge-file command
# there should always be conflicts, otherwise we wouldn't have been called
status = os.system('git merge-file --diff3 --marker-size=%d -L "Current version" -L "Base version" -L "Other version" %s %s %s' % (marker_len, current, base, other))
num_conflicts = os.WEXITSTATUS(status)
assert num_conflicts > 0

# make temporary files
# one is a copy of the conflicted 'current', to iterate with
# three are used to hold the different versions of each conflicted hunk
# open with 'a' so we can append without worrying about newline characters
tmp = tempfile.TemporaryFile()
with open(current, 'r') as c: tmp.write(c.read())
tmp.seek(0)
hunk = [ tempfile.TemporaryFile(mode='a+'), tempfile.TemporaryFile(mode='a+'), tempfile.TemporaryFile(mode='a+') ]

# process file line by line
abort = False
resolved = zone = index = 0

for line in tmp:

    # conflict zones
    if line.startswith(marker_start):
        zone = 1
        for f in hunk: f.truncate(0)
    elif line.startswith(marker_base): zone = 2
    elif line.startswith(marker_other): zone = 3

    # end of conflict zone
    elif line.startswith(marker_end):

        index += 1

        # get number of lines in current, base and other hunks
        sizes = [file_len(f) for f in hunk]

        first_run = True

        # ask user for action to take
        while True:

            if first_run:
                print ''
                action = 'v'
                first_run = False
            else:
                print color.BOLD + color.BLUE + '\nConflicted hunk %d of %d (spans %d/%d/%d lines) in %s...' % (index, num_conflicts, sizes[0], sizes[1], sizes[2], filename) + color.END
                print color.BOLD + '   v - view entire hunk' + color.END
                print color.BOLD + '   x - view hunk in context' + color.END
                print color.BOLD + '   c - view current version' + color.END
                print color.BOLD + '   b - view base version' + color.END
                print color.BOLD + '   o - view other version' + color.END
                print color.BOLD + '   s - attempt sub-line merge' + color.END
                print color.BOLD + '   m - resolve manually' + color.END
                print color.BOLD + '   k - skip this hunk' + color.END
                print color.BOLD + '   a - abort merge' + color.END
                action = ask_for_input('Resolve this hunk', ['v','x','c','b','o','s','m','k','a'])
                print ''

            # actions
            for f in hunk: f.seek(0)
            if action == 'x':
                start, stop = find_nth_conflicted_hunk(current, index-resolved)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(max(0, start-10), start):
                            print l.rstrip('\n')
                        elif i >= start:
                            break
            if action in ['v','x','c']:
                print color.RED + marker_start + ' Current version is:\n' + color.END + hunk[0].read().rstrip('\n')
            if action in ['v','x','b']:
                print color.RED + marker_base + ' Base version was:\n' + color.END + hunk[1].read().rstrip('\n')
            if action in ['v','x','o']:
                print color.RED + marker_other + ' Other version is:\n' + color.END + hunk[2].read().rstrip('\n')
            if action in ['v','x','c','b','o']:
                print color.RED + marker_end + color.END
            if action == 'x':
                length = file_len(current)
                with open(current, 'r') as c:
                    for i,l in enumerate(c):
                        if i in range(stop, min(stop+10, length)):
                            print l.rstrip('\n')
                        elif i >= stop:
                            break
            elif action == 's':
                result = subline_merge_hunk(hunk)
                if result is not None:
                    print '\n' + color.RED + marker_start + ' Sub-line merge yields:' + color.END
                    if len(result): print '\n'.join([x.rstrip('\n') for x in result])
                    print color.RED + marker_end + color.END + '\n'
                    accept = ask_for_input('Accept sub-line merge', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        resolved += 1
                        break
                else:
                    print color.BOLD + color.RED + 'Sub-line merge failed, hunk not self-consistent or has overlapping changes' + color.END
            elif action == 'm':
                result = manual_merge_hunk(hunk)
                if result is not None:
                    print '\n' + color.RED + marker_start + ' Manual resolution is:' + color.END
                    if len(result): print '\n'.join([x.rstrip('\n') for x in result])
                    print color.RED + marker_end + color.END + '\n'
                    accept = ask_for_input('Accept manual resolution', ['y','n'])
                    success = True if accept == 'y' else False
                    if (success):
                        replace_nth_conflicted_hunk_with_lines(current, index-resolved, result)
                        resolved += 1
                        break
                else:
                    print color.BOLD + color.YELLOW + 'User cancelled manual resolve' + color.END
            elif action == 'k':
                break
            elif action == 'a':
                abort = True
                break
        zone = 0

    # append line to conflict zone file
    elif zone:
        hunk[zone-1].write(line)

    if abort: break


# close all temp files (will be automatically deleted)
tmp.close()
for h in hunk: h.close()

# print resolution
col = color.GREEN if resolved == num_conflicts else color.YELLOW if resolved > 0 else color.RED
print col + color.BOLD + '\nResolved %d of %d conflicts in %s\n' % (resolved, num_conflicts, filename) + color.END

# only exit with success if all conflicts were resolved
sys.exit(0 if resolved == num_conflicts else 1)

